This program should be regarded as a DEBUGGING aid, not as a 
certifier of correctness.
Call with the -l flag or read the license file for terms
and conditions of use.

Bugs, questions, and comments should be directed to
"murphi@verify.stanford.edu".

Murphi compiler last modified date: Jan 29 1999
Include files   last modified date: Jan 29 1999
==========================================================================
Options:
1) General:
	-h            help.
	-l            print license.
2) Verification Strategy: (default: -v)
	-s            simulate.
	-v or -vbfs   verify with breadth-first search.
	-vdfs         verify with depth-first search.
	-ndl          do not check for deadlock.
3) Others Options: (default: -m8, -p3, -loop1000)
	-m<n>         amount of memory for closed hash table in Mb.
	-k<n>         same, but in Kb.
	-loop<n>      allow loops to be executed at most n times.
	-p            make simulation or verification verbose.
	-p<n>         report progress every 10^n events, n in 1..5.
	-pn           print no progress reports.
	-pr           print out rule information.
4) Error Trace Handling: (default: -tn)
	-tv           write a violating trace (with default -td).
	-td           write only state differences from the previous states.
	              (in simulation mode, write only state differences in
	               verbose mode.)
	-tf           write full states in trace.
	              (in simulation mode, write full states in verbose mode.)
	-ta           write all generated states at least once.
	-tn           write no trace (default).
5) Reduction Technique: (default: -sym3 with -permlimit 10 and multiset
                                  reduction)
	-nosym        no symmetry reduction (multiset reduction still effective)
	-nomultiset   no multiset reduction
	-sym<n>       reduction by symmetry
	-permlimit<n> max num of permutation checked in alg 3
	              (for canonicalization, set it to zero)
	              n | methods
	              -----------------------------------
	              1 | exhaustive canonicalize
	              2 | heuristic fast canonicalization
	                  (can be slower or faster than alg 3 canonicalization)
	                  (use a lot of auxiliary memory for large scalarsets)
	              3 | heuristic small mem canonicaliztion/normalization
	                  (depends on -permlimit)
	              4 | heuristic fast normalization (alg 3 with -permlimit 1)

